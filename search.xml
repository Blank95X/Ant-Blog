<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>springboot 初识</title>
    <url>/1266698458.html</url>
    <content><![CDATA[<h1 id="springboot-是什么"><a class="markdownIt-Anchor" href="#springboot-是什么"></a> springboot 是什么</h1>
<p>springboot 是 spring 框架的一个子部件，用于快速构建 spring web 项目。</p>
<h2 id="快速构建"><a class="markdownIt-Anchor" href="#快速构建"></a> 快速构建</h2>
<ol>
<li>创建 maven 工程</li>
<li>导入起步依赖：spring-boot-starter-web</li>
<li>提供启动类</li>
<li>编写 Controller</li>
</ol>
<p>如果使用 IDEA 进行构建，只需要手动进行第四步，其他的会自动完成。</p>
<p>启动类：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F; springboot工程启动类
@SpringBootApplication
public class SpringbootQuickstartApplication &#123;

    public static void main(String[] args) &#123;
        SpringApplication.run(SpringbootQuickstartApplication.class, args);
        &#x2F;&#x2F; 两个参数：当前类的class文件、启动参数
    &#125;

&#125;</code></pre>
<p>编写 Controller ：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">@RestController
public class HelloController &#123;
    @RequestMapping(&quot;&#x2F;hello&quot;)
    public String hello() &#123;
        return &quot;hello!&quot;;
    &#125;
&#125;</code></pre>
<p>运行项目后，访问 localhost:8080/hello ，可以看到 <code>hello!</code> 这个字符串。</p>
<div class="note info"><p>手动创建工程只需要创建文件即可，比如：</p>
<ol>
<li><code>pom.xml</code> 文件，并手动导入依赖；</li>
<li>启动类</li>
<li>Controller<br />
有了这三个文件就可以启动了，这是一个最小的 springboot 项目。</li>
</ol>
</div>
<hr />
<h1 id="applicationproperties-配置文件"><a class="markdownIt-Anchor" href="#applicationproperties-配置文件"></a> application.properties 配置文件</h1>
<p><code>/resources</code> 目录下的 <code>application.properties</code> 或者 <code>application.yml</code> 是项目的配置文件。它们的作用是相同的，只是语法格式不同。<code>springboot</code> 会自动识别并读取其中的配置。</p>
<h2 id="编写配置信息"><a class="markdownIt-Anchor" href="#编写配置信息"></a> 编写配置信息</h2>
<p>以修改项目相关配置为例：</p>
<pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml">server:
    port: 9090 # 项目启动端口
    servlet:
        context-path: &#x2F;root # 站点虚拟根路径</code></pre>
<h2 id="获取配置信息"><a class="markdownIt-Anchor" href="#获取配置信息"></a> 获取配置信息</h2>
<p>有一个自定义类 <code>getConfigInfo</code> ：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">public class getConfigInfo &#123;
    public int one;
    public String two;
    public boolean three;
&#125;</code></pre>
<p>配置文件如下：</p>
<pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml">key:
    one: 1
    two: er
    three: true</code></pre>
<p>需要获取配置信息时，使用 <code>@Value</code> 注解：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">public class getConfigInfo &#123;
    @Value(&quot;$&#123;key.one&#125;&quot;)
    public int one;

    @Value(&quot;$&#123;key.two&#125;&quot;)
    public String two;

    @Value(&quot;$&#123;key.three&#125;&quot;)
    public boolean three;
&#125;</code></pre>
<p>如果字段名太多呢？显然它们都有一个共同的前缀 <code>key</code> 。那么就可以使用 <code>@ConfigurationProperties</code> 注解：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">@ConfigurationProperties(prefix &#x3D; &quot;key&quot;) &#x2F;&#x2F; prefix 的值是共同前缀
public class getConfigInfo &#123;
    public int one;
    public String two;
    public boolean three;
&#125;</code></pre>
<p>使用该注解来<strong>自动获取键值</strong>的前提是类中的<strong>属性名</strong>与配置文件中的<strong>键名</strong>一致。</p>
<div class="link-grid"><div class="link-grid-container">
<object class="link-grid-image" data="https://docs.spring.io/spring-boot/_/img/spring-logo.svg"></object>
<p>Spring 官方文档</p><p>Common Application Properties</p>
<a href="https://docs.spring.io/spring-boot/appendix/application-properties/index.html#appendix.application-properties"></a>
</div></div>]]></content>
      <categories>
        <category>spring</category>
        <category>springboot</category>
      </categories>
      <tags>
        <tag>springboot</tag>
      </tags>
  </entry>
  <entry>
    <title>bean 对象</title>
    <url>/978272554.html</url>
    <content><![CDATA[<h1 id="自动扫描-bean-对象"><a class="markdownIt-Anchor" href="#自动扫描-bean-对象"></a> 自动扫描 bean 对象</h1>
<p>在 springboot 中，扫描 bean 的路径由注解 <code>@ComponentScan</code> 指定：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">@ComponentScan(basePackages &#x3D; &quot;com.example.demo&quot;)</code></pre>
<p>springboot 的启动类注解已经包含了这个注解：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">@SpringBootConfiguration
@EnableAutoConfiguration
@ComponentScan
public @interface SpringBootApplication&#123;
    &#x2F;&#x2F; code ...
&#125;</code></pre>
<p>springboot 默认扫描<strong>启动类所在的包及其子包</strong>。所以只需要在规定的路径内编写代码，即可自动扫描。</p>
<p>如果希望可以扫描启动类的包之外的 bean ，可以为其添加注解 <code>@ComponentScan</code> 来指定。</p>
<h1 id="bean-注册"><a class="markdownIt-Anchor" href="#bean-注册"></a> bean 注册</h1>
<p>基础的注册注解：</p>
<table>
<thead>
<tr>
<th style="text-align:center">注解</th>
<th style="text-align:center">说明</th>
<th style="text-align:center">位置</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>@Component</code></td>
<td style="text-align:center">声明 bean 的基础注解</td>
<td style="text-align:center">不属于以下三类时使用</td>
</tr>
<tr>
<td style="text-align:center"><code>@Controller</code></td>
<td style="text-align:center"><code>@Component</code> 的衍生注解</td>
<td style="text-align:center">标注于控制类</td>
</tr>
<tr>
<td style="text-align:center"><code>@Service</code></td>
<td style="text-align:center"><code>@Component</code> 的衍生注解</td>
<td style="text-align:center">标注于业务类</td>
</tr>
<tr>
<td style="text-align:center"><code>@Repository</code></td>
<td style="text-align:center"><code>@Component</code> 的衍生注解</td>
<td style="text-align:center">标注于数据访问类</td>
</tr>
</tbody>
</table>
<p>如果 bean 对象来自第三方，是无法使用 <code>@Component</code> 及其衍生注解的。</p>
<h2 id="注册第三方-bean"><a class="markdownIt-Anchor" href="#注册第三方-bean"></a> 注册第三方 bean</h2>
<h3 id="bean-注解"><a class="markdownIt-Anchor" href="#bean-注解"></a> @Bean 注解</h3>
<p>可以在启动类中使用：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">@springBootApplication
public class SpringBootRegisterApplicationf&#123;
    
    &#x2F;&#x2F;将方法返回值交给Ioc容器管理，成为Ioc容器的bean对象 
    @Bean
    public OtherBean otherBean()&#123;
        return new OtherBean();
    &#125; 

    &#x2F;&#x2F; 验证注入是否成功
    public static void main(String[] args) &#123;
        &#x2F;&#x2F; 获取当前容器
        ApplicationContext context &#x3D; SpringApplication.run(SpringbootQuickstartApplication.class, args);
        &#x2F;&#x2F; 获取注入的 Bean
        OtherBean otherBean &#x3D; context.getBean(OtherBean.class);
        &#x2F;&#x2F; 如果没有报错说明注入成功
        System.out.println(otherBean);
    &#125;

&#125;</code></pre>
<p>注入的 Bean 对象的默认名为方法名。可以自定义名字：</p>
<pre class="line-numbers language-diff" data-language="diff"><code class="language-diff">- @Bean
+ @Bean(name &#x3D; &quot;yourName&quot;)
+ @Bean(&quot;yourName&quot;)</code></pre>
<pre class="line-numbers language-diff" data-language="diff"><code class="language-diff">&#x2F;&#x2F; 获取注入的 Bean
- OtherBean otherBean &#x3D; context.getBean(OtherBean.class);
+ OtherBean otherBean &#x3D; context.getBean(&quot;yourName&quot;);</code></pre>
<p>但是启动类不应该做这些工作。可以使用 <code>@Configuration</code> 来指定配置类。注意<strong>配置类需要在启动类所在包或其子包</strong>。</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">@Configuration
public class SpringBootRegisterApplication&#123;
    @Bean
    public OtherBean otherBean()&#123;
        return new OtherBean();
    &#125;
&#125;</code></pre>
<p>使用同样的方法在启动类中验证。</p>
<details class="note info"><summary><p>需要使用 ioc 中已存在的对象？</p>
</summary>
<p>如果方法的内部需要使用到ioc容器中已经存在的 bean 对象，那么只需要在方法上声明即可，springboot 会自动的注入：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">@Configuration
public class SpringBootRegisterApplication&#123;
    @Bean
    public OtherBean otherBean(AnotherBean anotherBean)&#123;
        &#x2F;&#x2F; 无报错则获取成功
        System.out.println(&quot;otherBean:&quot;+anotherBean);
        return new OtherBean();
    &#125;
&#125;</code></pre>

</details>
<h3 id="import-注解"><a class="markdownIt-Anchor" href="#import-注解"></a> @Import 注解</h3>
<p>如果<strong>配置类在启动类所在的包的外部</strong>呢？这时候可以使用 <code>@Import</code> 注解。</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">@SpringBootApplication
@Import(yourConfigClass.class)
public class SpringbootBeanInApplication &#123;

    public static void main(String[] args) &#123;
       &#x2F;&#x2F; code ...
    &#125;
&#125;</code></pre>
<p>当然也可以把配置类的完整类路径传递给 <code>@Import</code> 注解。</p>
<pre class="line-numbers language-diff" data-language="diff"><code class="language-diff">- @Import(yourConfigClass.class)
+ @Import(&quot;com.example.demo.config.yourConfigClass&quot;)</code></pre>
<p>有多个配置类需要传入时，可以写为数组的形式。</p>
<pre class="line-numbers language-diff" data-language="diff"><code class="language-diff">- @Import(yourConfigClass.class)
+ @Import(FirstConfigClass,SecondConfigClass,ThirdConfigClass)</code></pre>
<details class="note info"><summary><p>配置类太多？</p>
</summary>
<p>如果配置类太多，那么 <code>@Import</code> 注解就会很长。可以通过实现 <code>ImportSelector</code> 接口来解决。</p>
<p>首先在 <code>resources</code> 目录下新建一个文件 <code>common.imports</code> ，里面写入需要导入的配置类的完整类路径：</p>
<pre class="line-numbers language-none"><code class="language-none">com.example.demo.config.FirstConfigClass
com.example.demo.config.SecondConfigClass
com.example.demo.config.ThirdConfigClass
...</code></pre>
<p>然后新建配置总类，实现 <code>ImportSelector</code> 接口：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">public class CommonImportselector implements Importselector &#123;
    @override
    public String[] selectImports(AnnotationMetadata importingClassMetadata) &#123;
        &#x2F;&#x2F;读取配置文件的内容
        List &lt;String&gt; imports &#x3D; new ArrayList&lt;&gt;();
        Inputstream is &#x3D; CommonImportSelector.class.getclassLoader().getResourceAsstream(&quot;common.imports&quot;);
        BufferedReader br &#x3D; new BufferedReader(new InputstreamReader(is));
        String line &#x3D; null;
        try &#123;
            while ((line &#x3D; br.readLine()) !&#x3D; nul)
                &#x2F;&#x2F; 添加到字符串数组中
                imports.add(line);
        &#125; catch（ IOException e） &#123;
            throw new RuntimeException(e);
            finally &#123;
                if (br !&#x3D; null) &#123;
                    try &#123;
                        &#x2F;&#x2F; 关闭流
                        br.close();
                    &#125; catch (IoExceptione) &#123;
                        throw newRuntimeException(e);
                    &#125;
                &#125;
                &#x2F;&#x2F; 返回字符串数组
                return imports.toArray(new String[0]);
            &#125;
        &#125;
    &#125;
&#125;</code></pre>
<p>这样只需要在启动类中使用 <code>@Import(CommonImportSelector.class)</code> 即可。它会自动执行方法 <code>selectImports()</code> ，并获取其返回值作为配置类。</p>
<details class="note primary"><summary><p>不想每次都写配置总类的路径？</p>
</summary>
<p>可以自定义一个包装注解。在 IDEA 中新建一个注解类：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">@Target(ElementType.TYPE) &#x2F;&#x2F; 表明该注解可以在类上使用
@Retention(RetentionPolicy.RUNTIME) &#x2F;&#x2F; 表明该注解会保留在运行时阶段
@Import(CommonImportSelector.class) &#x2F;&#x2F; 导入刚刚编写的配置总类
public @interface EnableCommonConfig &#123;
    &#x2F;&#x2F; 不用写其他内容
&#125;</code></pre>
<p>这样在启动类中只需要使用 <code>@EnableCommonConfig</code> 即可。</p>
</details>
</details>
]]></content>
      <categories>
        <category>springboot</category>
      </categories>
      <tags>
        <tag>springboot</tag>
        <tag>bean</tag>
      </tags>
  </entry>
  <entry>
    <title>PowerShell：在此系统上禁止运行脚本</title>
    <url>/2106263798.html</url>
    <content><![CDATA[<p>查看当前用户的执行策略：</p>
<pre class="line-numbers language-powershell" data-language="powershell"><code class="language-powershell">get-executionpolicy</code></pre>
<p>返回 <code>Restricted</code> （默认）则是无法执行脚本。</p>
<p>解除限制：</p>
<pre class="line-numbers language-powershell" data-language="powershell"><code class="language-powershell">set-executionpolicy remotesigned</code></pre>
<p>如果运行后提示：</p>
<pre class="line-numbers language-powershell" data-language="powershell"><code class="language-powershell">Windows PowerShell 已成功更新你的执行策略，但在更具体的作业域中定义的策略覆盖该设置了。由于发生覆盖，你的外壳程序将保留当前的有效执行策略受限制。</code></pre>
<p>说明当前用户的策略还未更改，继续执行：</p>
<pre class="line-numbers language-powershell" data-language="powershell"><code class="language-powershell">Set-ExecutionPolicy RemoteSigned -Scope CurrentUser</code></pre>
<p>再次查看当前用户的执行策略，发现已更改。</p>
<pre class="line-numbers language-powershell" data-language="powershell"><code class="language-powershell">&gt; get-executionpolicy
RemoteSigned</code></pre>
<p>之后就可以执行脚本了。</p>
<div class="link-grid"><div class="link-grid-container">
<object class="link-grid-image" data="https://syxdevcode.github.io/images/favicon-32x32-next.png"></object>
<p>syxdevcode的博客</p><p>PowerShell：因为在此系统上禁止运行脚本，解决方法</p>
<a href="https://syxdevcode.github.io/2021/09/04/PowerShell%EF%BC%9A%E5%9B%A0%E4%B8%BA%E5%9C%A8%E6%AD%A4%E7%B3%BB%E7%BB%9F%E4%B8%8A%E7%A6%81%E6%AD%A2%E8%BF%90%E8%A1%8C%E8%84%9A%E6%9C%AC%EF%BC%8C%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/"></a>
</div><div class="link-grid-container">
<object class="link-grid-image" data="https://smallsquare.github.io/img/creeper.png"></object>
<p>smallsquare的博客</p><p>解决Powershell阻止脚本运行遇到的问题 Powershell禁用运行脚本的解决方案</p>
<a href="https://smallsquare.github.io/Powershell-disable-runing-scripts/"></a>
</div></div>]]></content>
      <categories>
        <category>疑难杂症</category>
      </categories>
      <tags>
        <tag>windows</tag>
      </tags>
  </entry>
  <entry>
    <title>新建博客时自动以时间命名文件</title>
    <url>/3338553697.html</url>
    <content><![CDATA[<h1 id="配置-js-脚本"><a class="markdownIt-Anchor" href="#配置-js-脚本"></a> 配置 js 脚本</h1>
<p>在 blog 根目录下新建文件 <code>new_post_with_date.js</code> ：</p>
<pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">const &#123; exec &#125; &#x3D; require(&#39;child_process&#39;);
const moment &#x3D; require(&#39;moment&#39;);

&#x2F;&#x2F; 获取当前日期时间，格式为 &#39;YYYY-MM-DD-HH-mm-ss&#39;
const dateTime &#x3D; moment().format(&#39;YYYY-MM-DD-HH-mm-ss&#39;);

&#x2F;&#x2F; 定义文章标题
const title &#x3D; &#96;$&#123;dateTime&#125;&#96;;

&#x2F;&#x2F; 执行 Hexo new 命令创建新文章
exec(&#96;hexo new &quot;$&#123;title&#125;&quot;&#96;, (error, stdout, stderr) &#x3D;&gt; &#123;
    if (error) &#123;
        console.error(&#96;执行出错: $&#123;error&#125;&#96;);
        return;
    &#125;
    console.log(stdout);
    if (stderr) &#123;
        console.error(&#96;标准错误: $&#123;stderr&#125;&#96;);
    &#125;
&#125;);</code></pre>
<p>之后安装 <code>moment</code> 库来处理时间和日期：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">npm install monent</code></pre>
<h1 id="新建博客"><a class="markdownIt-Anchor" href="#新建博客"></a> 新建博客</h1>
<p>这样新建博客需要使用 <code>node new_post_with_date.js</code> 命令，生成的文件自动以当前时间命名。</p>
<p>可以修改 <code>new_post_with_date.js</code> 文件来自定义生成的文件名。</p>
]]></content>
      <categories>
        <category>软件工具</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>GitHubPages+hexo 部署个人在线博客</title>
    <url>/13345652.html</url>
    <content><![CDATA[<p>系统环境： windows11</p>
<h1 id="安装-hexo"><a class="markdownIt-Anchor" href="#安装-hexo"></a> 安装 hexo</h1>
<p>先决条件： <code>nodejs</code> 和 <code>git</code> 环境，这里不赘述。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">npm install -g hexo-cli</code></pre>
<p>验证是否安装成功：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">hexo -v</code></pre>
<h1 id="本地部署"><a class="markdownIt-Anchor" href="#本地部署"></a> 本地部署</h1>
<p>初始化：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">hexo init &lt;floder&gt;
cd &lt;floder&gt;
npm install</code></pre>
<p>部署：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">hexo server</code></pre>
<p>在<a href="http://localhost:4000">localhost:4000</a>查看博客界面。</p>
<h1 id="部署到-github-pages"><a class="markdownIt-Anchor" href="#部署到-github-pages"></a> 部署到 github pages</h1>
<h2 id="生成-sshkey"><a class="markdownIt-Anchor" href="#生成-sshkey"></a> 生成 sshkey</h2>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">ssh-keygen -r rsa -C &quot;youremail@example.com&quot;</code></pre>
<p>一直按回车即可。如果提示 sshkey 已存在，选择覆盖（后果自负）。</p>
<p>生成的密钥保存在 <code>C:\Users\yourusername\.ssh\id_rsa.pub</code> 这个文件中，下一步要用。</p>
<h2 id="创建-github-pages-仓库"><a class="markdownIt-Anchor" href="#创建-github-pages-仓库"></a> 创建 github pages 仓库</h2>
<p>在 github 上创建名为 <code>yourusername.github.io</code> 的仓库。</p>
<p>在 github 上打开个人设置，在侧边栏找到 <code>SSH and GPG keys</code> ，点击它。之后在右边找到 <code>New SSH key</code> ，点击它。</p>
<p><code>Title</code> 随意填写，<code>Key type</code> 选择 <code>Authentication Key</code> 。用任意文本编辑器打开上一步生成的密钥文件，复制里面所有内容，粘贴到 <code>key</code> 部分。然后点击 <code>Add SSH key</code> 确认。</p>
<h2 id="填写仓库配置"><a class="markdownIt-Anchor" href="#填写仓库配置"></a> 填写仓库配置</h2>
<p>回到本地博客的文件夹内，找到 <code>_config.yml</code> 这个文件，打开。</p>
<p>在文件末尾找到：</p>
<pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml">deploy:
  type: &#39;&#39;</code></pre>
<p>改成：</p>
<pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml">deploy:
  type: git
  repository: https:&#x2F;&#x2F;github.com&#x2F;explame&#x2F;explame.github.io.git # 你的仓库的 git 链接
  branch: main # 也可能是 master ，具体查看自己的仓库。</code></pre>
<h2 id="安装一键部署工具并上传"><a class="markdownIt-Anchor" href="#安装一键部署工具并上传"></a> 安装一键部署工具并上传</h2>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">npm install hexo-deployer-git --save</code></pre>
<p>清理文件并上传：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">hexo clean &amp;&amp; hexo deploy</code></pre>
<p>片刻之后可以查看名为你的仓库名的URL，看看是否部署成功。</p>
<p>例子： <a href="http://yourusername.github.io">http://yourusername.github.io</a></p>
<hr />
<p>参考文章</p>
<p><a href="https://hexo.io/zh-cn/docs/github-pages.html">hexo官方文档</a></p>
]]></content>
      <categories>
        <category>软件工具</category>
      </categories>
      <tags>
        <tag>windows</tag>
        <tag>hexo</tag>
        <tag>github</tag>
      </tags>
  </entry>
  <entry>
    <title>Acvitity 初识</title>
    <url>/1273076805.html</url>
    <content><![CDATA[<h1 id="要素"><a class="markdownIt-Anchor" href="#要素"></a> 要素</h1>
<p>创建一个 Activity 需要以下要素：</p>
<p>Activity 类：</p>
<pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin">class ActivityName : ComponentActivity() &#123;
	override fun onCreate(savedInstanceState: Bundle?) &#123;
        super.onCreate(savedInstanceState)
        &#x2F;&#x2F; code..
    &#125;
&#125;</code></pre>
<p>布局文件： <code>src/main/res/layout/activity_name.xml</code></p>
<p>在 AndroidManifest.xml 文件中注册：</p>
<pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;activity android:name&#x3D;&quot;.ActivityName&quot; 
    android:label&#x3D;&quot;This is ActivityName&quot;&gt;
    &lt;!--如果需要作为主界面，还需要以下两个属性--&gt;
    &lt;intent-filter&gt;
        &lt;action android:name&#x3D;&quot;android.intent.action.MAIN&quot; &#x2F;&gt; 
        &lt;category android:name&#x3D;&quot;android.intent.category.LAUNCHER&quot; &#x2F;&gt;
    &lt;&#x2F;intent-filter&gt;
&lt;&#x2F;activity&gt;</code></pre>
<h1 id="获取控件"><a class="markdownIt-Anchor" href="#获取控件"></a> 获取控件</h1>
<p>一般使用 <code>findViewById</code> 方法获取控件：</p>
<pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin">val textView &#x3D; findViewById&lt;TextView&gt;(R.id.textView)</code></pre>
<p>使用 kotlin 的安卓项目中，可以在模块级 <code>build.gradle</code> 文件中启用 <code>viewBindding</code>：</p>
<pre class="line-numbers language-gradle" data-language="gradle"><code class="language-gradle">android &#123;
    ...
    viewBinding &#123;
        enabled &#x3D; true
    &#125;
&#125;</code></pre>
<p>这样就可以直接使用控件 id 获取控件：</p>
<pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin">val binding &#x3D; ActivityMainBinding.inflate(layoutInflater)
setContentView(binding.root)
val button1 &#x3D; binding.button1</code></pre>
<p>同时 Android Studio 会自动生成一个 <code>import com.example.app.databinding.ActivityMainBinding</code> 语句。</p>
<h1 id="生命周期"><a class="markdownIt-Anchor" href="#生命周期"></a> 生命周期</h1>
<p>安卓系统使用 task 来管理 Activity ，一个 task 就是存放在返回栈中的 Activity 集合。</p>
<p>每个 Activity 都有一个生命周期，包括以下几个状态：</p>
<table>
<thead>
<tr>
<th style="text-align:center">状态</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">运行状态</td>
<td style="text-align:center">完全可见，位于栈顶</td>
</tr>
<tr>
<td style="text-align:center">暂停状态</td>
<td style="text-align:center">可见，不位于栈顶</td>
</tr>
<tr>
<td style="text-align:center">停止状态</td>
<td style="text-align:center">完全不可见，不位于栈顶</td>
</tr>
<tr>
<td style="text-align:center">销毁状态</td>
<td style="text-align:center">从栈中移除</td>
</tr>
</tbody>
</table>
<p>对应的回调方法：</p>
<table>
<thead>
<tr>
<th style="text-align:center">方法</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>onCreate</code></td>
<td style="text-align:center">创建时调用</td>
</tr>
<tr>
<td style="text-align:center"><code>onStart</code></td>
<td style="text-align:center">启动时调用</td>
</tr>
<tr>
<td style="text-align:center"><code>onResume</code></td>
<td style="text-align:center">恢复时调用</td>
</tr>
<tr>
<td style="text-align:center"><code>onPause</code></td>
<td style="text-align:center">暂停时调用</td>
</tr>
<tr>
<td style="text-align:center"><code>onStop</code></td>
<td style="text-align:center">停止（完全不可见）时调用</td>
</tr>
<tr>
<td style="text-align:center"><code>onReStart</code></td>
<td style="text-align:center">重启时调用</td>
</tr>
<tr>
<td style="text-align:center"><code>onDestroy</code></td>
<td style="text-align:center">销毁时调用</td>
</tr>
</tbody>
</table>
<pre class="mermaid">graph TD
    A((启动Activity)) --> B[onCreate]
    B --> C[onStart]
    C --> D[onResume]
    D --> E((Activity运行中))

    E --> |其他Activity来到前台| F[onPause] 

    F --> |Activity不再可见| G[onStop]
    G --> |Activity被销毁| H[onDestroy]
    H --> I((关闭Activity))

    F --> |返回上一个Activity| D
    
    G --> |返回上一个Activity| K[onReStart]
    K --> C

    G & F --> |其他优先级高的程序需要内存| J((杀掉进程))
    J --> |返回上一个Activity| B</pre>
<h2 id="临时保存数据"><a class="markdownIt-Anchor" href="#临时保存数据"></a> 临时保存数据</h2>
<p>在 Activity 生命周期中，有时需要保存数据，可以使用 <code>onSaveInstanceState</code> 方法：</p>
<pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin">override fun onSaveInstanceState(outState: Bundle) &#123;
    super.onSaveInstanceState(outState)
    outState.putString(&quot;key&quot;, &quot;value&quot;)
&#125;</code></pre>
<p>在 <code>onCreate</code> 方法中获取：</p>
<pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin">override fun onCreate(savedInstanceState: Bundle?) &#123;
    super.onCreate(savedInstanceState)
    if (savedInstanceState !&#x3D; null) &#123;
        val value &#x3D; savedInstanceState.getString(&quot;key&quot;)
    &#125;
&#125;</code></pre>
<h1 id="启动模式"><a class="markdownIt-Anchor" href="#启动模式"></a> 启动模式</h1>
<p>Activity 的启动模式有以下几种：</p>
<table>
<thead>
<tr>
<th style="text-align:center">模式</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>standard</code>（默认）</td>
<td style="text-align:center">每次启动都会创建一个新的 Activity 实例，不管栈中是否已经存在</td>
</tr>
<tr>
<td style="text-align:center"><code>singleTop</code></td>
<td style="text-align:center">如果栈顶是该 Activity 实例，则直接使用；否则创建新实例</td>
</tr>
<tr>
<td style="text-align:center"><code>singleTask</code></td>
<td style="text-align:center">如果栈中已经存在该 Activity 实例，则将其上方的 Activity 实例全部出栈；否则创建新实例</td>
</tr>
<tr>
<td style="text-align:center"><code>singleInstance</code></td>
<td style="text-align:center">该 Activity 实例独立于其他 Activity 实例，单独存在一个任务栈中</td>
</tr>
</tbody>
</table>
<p>singleInstance 模式图解：</p>
<pre class="mermaid">graph LR
    subgraph 返回栈A
        A1[Activity1]
        A2[Activity2]

        A1 --> |返回| A2
    end

    subgraph 返回栈B
        A3[Activity3]
    end

        A2 --> |返回| A3
        A2 --> |启动新Activity| A3

        A3 --> |启动新Activity| A1</pre>
<p>Activity 的启动模式可以在 AndroidManifest.xml 文件中设置：</p>
<pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;activity android:name&#x3D;&quot;.ActivityName&quot; 
    android:launchMode&#x3D;&quot;singleTop&quot;&gt;
&lt;&#x2F;activity&gt;</code></pre>
<h1 id="一些实践"><a class="markdownIt-Anchor" href="#一些实践"></a> 一些实践</h1>
<h2 id="查看当前所在-activity"><a class="markdownIt-Anchor" href="#查看当前所在-activity"></a> 查看当前所在 Activity</h2>
<pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin">Log.d(TAG, this.toString())
Log.d(TAG, this.javaClass.simpleName)
Log.d(TAG, javaClass.simpleName)</code></pre>
<p>this 是当前 Activity 的实例引用，this.javaClass.simpleName 和 javaClass.simpleName 都是当前 Activity 的类名。</p>
<p>输出：</p>
<pre class="line-numbers language-none"><code class="language-none">com.example.activitytest.FirstActivity@86bde1c
FirstActivity
FirstActivity</code></pre>
<p><code>@86bde1c</code>是当前 Activity 的哈希码，默认是内存地址的十六进制表示。</p>
<h2 id="一次性结束所有-activity"><a class="markdownIt-Anchor" href="#一次性结束所有-activity"></a> 一次性结束所有 Activity</h2>
<p>维护一个单例类 ActivityCollector 作为当前所有 Activity 的集合：</p>
<pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin">object ActivityCollector &#123;
    private val activities &#x3D; ArrayList&lt;Activity&gt;()

    fun addActivity(activity: Activity) &#123;
        activities.add(activity) &#x2F;&#x2F; 添加 Activity
    &#125;

    fun removeActivity(activity: Activity) &#123;
        activities.remove(activity) &#x2F;&#x2F; 移除 Activity
    &#125;

    fun finishAll() &#123;
        for (activity in activities) &#123;
            if (!activity.isFinishing) &#123; &#x2F;&#x2F; 判断 Activity 是否正在销毁
                activity.finish() &#x2F;&#x2F; 销毁 Activity
            &#125;
        &#125;
    &#125;
&#125;</code></pre>
<p>之后，在具体的 Activity 中重写 <code>onDestroy</code> 方法：</p>
<pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin">override fun onDestroy() &#123;
    super.onDestroy()
    ActivityCollector.removeActivity(this)
&#125;</code></pre>
<p>这样，在任意处，只要调用 <code>ActivityCollector.finishAll()</code> 方法，就可以一次性结束所有 Activity，达到一次性退出程序的目的。</p>
<h2 id="基本类"><a class="markdownIt-Anchor" href="#基本类"></a> 基本类</h2>
<p>创建一个基本类 BaseActivity，继承自 AppCompatActivity：</p>
<pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin">open class BaseActivity : AppCompatActivity() &#123;
    override fun onCreate(savedInstanceState: Bundle?) &#123;
        super.onCreate(savedInstanceState)
        Log.d(TAG, javaClass.simpleName)
        ActivityCollector.addActivity(this)
    &#125;

    override fun onDestroy() &#123;
        super.onDestroy()
        ActivityCollector.removeActivity(this)
    &#125;
&#125;</code></pre>
<p>之后，所有 Activity 都继承自 BaseActivity，这样就不必重写许多基本的方法。</p>
<h2 id="启动-activity-的最佳写法"><a class="markdownIt-Anchor" href="#启动-activity-的最佳写法"></a> 启动 Activity 的最佳写法</h2>
<p>如果一个 Activity 启动时需要传递数据，最佳写法是定义一个静态方法 <code>actionStart</code> ：</p>
<pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin">class YourActivity : BaseActivity() &#123;
    companion object &#123;
        fun actionStart(context: Context, data1: String, data2: String) &#123;
            val intent &#x3D; Intent(context, YourActivity::class.java)
            intent.putExtra(&quot;param1&quot;, data1)
            intent.putExtra(&quot;param2&quot;, data2)
            context.startActivity(intent)
        &#125;
    &#125;
&#125;</code></pre>
<p>kotlin规定，所有定义在 <code>companion object</code> 中的方法都可以使用类似于 java 静态方法的形式调用。</p>
<p>这样在其他地方启动 Activity 时，只需要调用 <code>YourActivity.actionStart(context, data1, data2)</code> 方法即可。</p>
]]></content>
      <categories>
        <category>第一个安卓 app</category>
        <category>Activity</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title>Intent 意图</title>
    <url>/3728271331.html</url>
    <content><![CDATA[<h1 id="intent-意图"><a class="markdownIt-Anchor" href="#intent-意图"></a> Intent 意图</h1>
<ul>
<li>在 Acitvity 之间跳转</li>
<li>传递数据</li>
<li>启动其他应用的 Activity</li>
</ul>
<p>能被外部启动的 Activity 都需要在 AndroidManifest.xml 文件中注册 <code>android:exported=&quot;true&quot;</code> 属性。</p>
<h2 id="显式-intent"><a class="markdownIt-Anchor" href="#显式-intent"></a> 显式 Intent</h2>
<pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin">val intent &#x3D; Intent(this, TargetActivity::class.java)
startActivity(intent)</code></pre>
<p><code>Intent</code> 构造函数的参数：</p>
<ol>
<li>上下文</li>
<li>目标活动的类名</li>
</ol>
<p><code>SecondActivity::class.java</code> 相当于 java 中 <code>SecondActivity.class</code> 的写法。</p>
<h2 id="隐式-intent"><a class="markdownIt-Anchor" href="#隐式-intent"></a> 隐式 Intent</h2>
<p>如果一个活动可以被隐式调用，需要在 AndroidManifest.xml 文件中注册：</p>
<pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;activity android:name&#x3D;&quot;.TargetActivity&quot;&gt;
    &lt;intent-filter&gt;
        &lt;action android:name&#x3D;&quot;com.example.activitytest.ACTION_START&quot; &#x2F;&gt;
        &lt;category android:name&#x3D;&quot;android.intent.category.DEFAULT&quot; &#x2F;&gt;
        &lt;!-- &lt;category android:name&#x3D;&quot;com.example.activitytest.MY_CATEGORY&quot;&#x2F;&gt; --&gt;
        &lt;!-- action 只能有一个， category 可以有多个--&gt;
    &lt;&#x2F;intent-filter&gt;
&lt;&#x2F;activity&gt;</code></pre>
<p>调用：</p>
<pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin">val intent &#x3D; Intent(&quot;com.example.activitytest.ACTION_START&quot;)
startActivity(intent)</code></pre>
<p>一个 Intent 可以指定一个 action 和多个 category，只有当 action 和 category 全部匹配时，意图才会被响应。</p>
<h2 id="传递数据"><a class="markdownIt-Anchor" href="#传递数据"></a> 传递数据</h2>
<p>活动1存放数据：</p>
<pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin">val intent &#x3D; Intent(this, TargetActivity::class.java)
intent.putExtra(&quot;extra_data&quot;, &quot;Hello, TargetActivity&quot;) &#x2F;&#x2F; key-value
startActivity(intent)</code></pre>
<p>活动2提取数据：</p>
<pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin">val extraData &#x3D; intent.getStringExtra(&quot;extra_data&quot;)</code></pre>
<h1 id="隐式传递的更多用法"><a class="markdownIt-Anchor" href="#隐式传递的更多用法"></a> 隐式传递的更多用法</h1>
<p>安卓系统中有一个内置 action <code>Intent.ACTION_VIEW</code> 可以打开浏览器：</p>
<pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin">val intent &#x3D; Intent(Intent.ACTION_VIEW)
intent.data &#x3D; Uri.parse(&quot;http:&#x2F;&#x2F;www.baidu.com&quot;) &#x2F;&#x2F; 设置网址，可选
startActivity(intent)</code></pre>
<p>当一个活动在 AndroidManifest.xml 中注册了 action 为 <code>Intent.ACTION_VIEW</code> 时，那么这个活动就可以响应打开网页的请求。</p>
<p>同时，还可以 <code>intent-filter</code> 标签中再配置一个 <code>data</code> 标签，用于更精确地指定当前 Activity 能够响应的数据。data 标签中主要可以配置以下内容：</p>
<table>
<thead>
<tr>
<th style="text-align:center">属性</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>android:scheme</code></td>
<td style="text-align:center">指定协议</td>
</tr>
<tr>
<td style="text-align:center"><code>android:host</code></td>
<td style="text-align:center">指定主机名</td>
</tr>
<tr>
<td style="text-align:center"><code>android:port</code></td>
<td style="text-align:center">指定端口</td>
</tr>
<tr>
<td style="text-align:center"><code>android:path</code></td>
<td style="text-align:center">指定访问路径</td>
</tr>
<tr>
<td style="text-align:center"><code>android:mimeType</code></td>
<td style="text-align:center">指定可以处理的数据类型，允许使用通配符</td>
</tr>
</tbody>
</table>
<p>只有当 data 标签中指定的内容和 Intent 中携带的 Data 完全一致时，当前 Activity 才能够响应该 Intent 。</p>
<blockquote>
<p>如果所有配置都正确，但是跳转的时候打开了系统默认的浏览器，将其禁用再尝试是否可以正常接收跳转浏览器的意图。</p>
</blockquote>
<h1 id="返回数据给上一个活动"><a class="markdownIt-Anchor" href="#返回数据给上一个活动"></a> 返回数据给上一个活动</h1>
<p>在父活动中使用 <code>startActivityForResult</code> 方法启动子活动：</p>
<pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin">val intent &#x3D; Intent(this, TargetActivity::class.java)
startActivityForResult(intent, 1) &#x2F;&#x2F; 1 是请求码，用于在之后的回调中判断数据来源</code></pre>
<p>子活动返回数据：</p>
<pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin">&#x2F;&#x2F; 主逻辑
val intent &#x3D; Intent()
intent.putExtra(&quot;data_return&quot;, &quot;Hello, MainActivity&quot;)
setResult(RESULT_OK, intent)
finish() &#x2F;&#x2F; 销毁当前活动</code></pre>
<p>父活动接收数据：</p>
<pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin">override fun onActivityResult(requestCode: Int, resultCode: Int, data: Intent?) &#123;
    when (requestCode) &#123;
        1 -&gt; &#123;
            if (resultCode &#x3D;&#x3D; Activity.RESULT_OK) &#123;
                val returnedData &#x3D; data?.getStringExtra(&quot;data_return&quot;)
                Log.d(&quot;MainActivity&quot;, &quot;returned data is $returnedData&quot;)
            &#125;
        &#125;
    &#125;
&#125;</code></pre>
<p>通过返回键返回时，子活动中重写 <code>onBackPressed</code> 方法即可：</p>
<pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin">override fun onBackPressed() &#123;
    &#x2F;&#x2F; code...
&#125;</code></pre>
]]></content>
      <categories>
        <category>第一个安卓 app</category>
        <category>Activity</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Intent</tag>
      </tags>
  </entry>
  <entry>
    <title>menu 控件</title>
    <url>/3976894431.html</url>
    <content><![CDATA[<h1 id="menu-控件"><a class="markdownIt-Anchor" href="#menu-控件"></a> menu 控件</h1>
<p>这里的 menu 控件是指标题栏右上角的菜单按钮。</p>
<p>在 <code>res/menu</code> 文件夹下创建一个 xml 文件，如 <code>main.xml</code>：</p>
<pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;utf-8&quot;?&gt;
&lt;menu xmlns:android&#x3D;&quot;http:&#x2F;&#x2F;schemas.android.com&#x2F;apk&#x2F;res&#x2F;android&quot;&gt;
    &lt;item
        android:id&#x3D;&quot;@+id&#x2F;add_item&quot;
        android:title&#x3D;&quot;Add&quot;&#x2F;&gt;
    &lt;item
        android:id&#x3D;&quot;@+id&#x2F;remove_item&quot;
        android:title&#x3D;&quot;Remove&quot;&#x2F;&gt;
&lt;&#x2F;menu&gt;</code></pre>
<p>在 Activity 中重写 <code>onCreateOptionsMenu</code> 方法：</p>
<pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin">override fun onCreateOptionsMenu(menu: Menu?): Boolean &#123;
    menuInflater.inflate(R.menu.main, menu) 
    &#x2F;&#x2F; menuInflater 这一部分其实是 kotlin 的语法糖，已经自动调用了 getter 方法
    &#x2F;* inflate 方法接收两个参数：
    第一个是 menu 布局资源文件，
    第二个是要设置这个布局的 menu 对象
    （从哪里来到哪里去）*&#x2F;
    return true
    &#x2F;&#x2F; 返回 true 表示菜单允许菜单显示
&#125;</code></pre>
<p>之后在 Activity 中重写 <code>onOptionsItemSelected</code> 方法可以自定义菜单选项响应事件。</p>
<pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin">override fun onOptionsItemSelected(item: MenuItem): Boolean &#123;
    when(item.itemId)&#123;
        R.id.add_item -&gt; Toast.makeText(this, &quot;add item&quot;,Toast.LENGTH_SHORT).show()
        R.id.remove_item -&gt; Toast.makeText(this,&quot;remove item&quot;,Toast.LENGTH_SHORT).show()
    &#125;
    return true
&#125;</code></pre>
<h2 id="显示toast"><a class="markdownIt-Anchor" href="#显示toast"></a> 显示Toast</h2>
<p><code>makeText()</code> 方法的参数：</p>
<ol>
<li>上下文</li>
<li>toast内容（字符串）</li>
<li>显示时长</li>
</ol>
<p>最后再调用 <code>show()</code> 方法即可。</p>
<h1 id="没有标题栏"><a class="markdownIt-Anchor" href="#没有标题栏"></a> 没有标题栏</h1>
<p>在确保 <code>res/values/styles.xml</code> 文件中的 <code>AppTheme</code> 主题中设置了标题栏的情况下：</p>
<ul>
<li>如果使用 <code>ComponentActivity</code> 作为活动的父类，需要手动设置标题栏。</li>
<li>使用 <code>AppCompatActivity</code> 作为活动的父类，可以自动设置标题栏。</li>
</ul>
]]></content>
      <categories>
        <category>第一个安卓 app</category>
        <category>布局和控件</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title>kotlin 基本语法</title>
    <url>/2766814441.html</url>
    <content><![CDATA[<h1 id="hello-kotlin"><a class="markdownIt-Anchor" href="#hello-kotlin"></a> hello kotlin</h1>
<p>在 IDEA 中新建一个 kotlin 项目，添加“ kotlin 文件”（注意不是类），输入以下代码，然后构建并运行，即可在终端看到输出。</p>
<pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin">fun main()&#123;
	println(&quot;hello kotlin&quot;)
&#125;</code></pre>
<p>语句末尾不需要分号。</p>
<h1 id="变量声明"><a class="markdownIt-Anchor" href="#变量声明"></a> 变量声明</h1>
<p>kotlin 只有两种变量声明关键字：</p>
<pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin">val a &#x3D; 10 &#x2F;&#x2F; 不可变变量
var b &#x3D; 20 &#x2F;&#x2F; 可变变量</code></pre>
<p>kotlin 可自动推导变量类型。也可显式声明变量类型。</p>
<pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin">val a : Int &#x3D; 10 &#x2F;&#x2F; 显式声明
val a &#x3D; 10 &#x2F;&#x2F; 隐式声明</code></pre>
<p><code>Int</code>为对象类型，而非 java 中的基本数据类型<code>int</code>。 kotlin 完全舍弃了 java 中的基本数据类型，每一个变量都是对象。</p>
<h1 id="函数声明"><a class="markdownIt-Anchor" href="#函数声明"></a> 函数声明</h1>
<pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin">fun funName(param1 : Int , param2 : Int) : Int&#123;
	&#x2F;&#x2F; code
	return 0
&#125;</code></pre>
<ul>
<li><code>param1 : Int , param2 : Int</code>声明变量名及其类型</li>
<li><code>: Int</code>声明返回值类型，不声明时返回空。</li>
</ul>
<p>两者都是可选的。</p>
<h2 id="语法糖"><a class="markdownIt-Anchor" href="#语法糖"></a> 语法糖</h2>
<p>当函数体只有一行时，可写为：</p>
<pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin">fun funName(param1 : Int , param2 : Int) : Int &#x3D; max(param1 : Int , param2 : Int)</code></pre>
<p>这里以<code>max</code>函数为例子，其作用是返回两者中较大的一个。</p>
<h1 id="流程控制"><a class="markdownIt-Anchor" href="#流程控制"></a> 流程控制</h1>
<h2 id="if"><a class="markdownIt-Anchor" href="#if"></a> if</h2>
<p>kotlin 中 if 有返回值：条件分支中的最后一行代码的返回值。</p>
<pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin">fun funName(num1 : Int , num2 : Int) : Int&#123;
	val value &#x3D; if(num1&gt;num2)&#123;
		num1
	&#125;else&#123;
		num2
	&#125;
	return value
&#125;</code></pre>
<p>显然<code>value</code>是多余的，可以直接返回判断体：</p>
<pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin">fun funName(num1 : Int , num2 : Int) : if(num1&gt;num2) num1 else num2</code></pre>
<p>这里写成了<a href="#%E8%AF%AD%E6%B3%95%E7%B3%96">语法糖</a>。</p>
<p>一般 if 语句不止一行，为什么也可以写成语法糖呢？我的理解是，如果函数体中只有一个逻辑块（一个判断流程，一条赋值语句等），就可以写成语法糖。</p>
<h2 id="when"><a class="markdownIt-Anchor" href="#when"></a> when</h2>
<p>作用约等于<code>switch</code>。</p>
<p>格式：</p>
<pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin">when( ... )&#123;
	匹配值 -&gt; &#123; 执行逻辑 &#125;
&#125;</code></pre>
<h3 id="精确匹配"><a class="markdownIt-Anchor" href="#精确匹配"></a> 精确匹配</h3>
<pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin">fun funName(name : String) &#x3D; when(name)&#123;
	&quot;Tom&quot; -&gt; &#123; 86 &#125;
	&quot;Jim&quot; -&gt; 77 &#x2F;&#x2F; 当只有一行时，花括号可以省略。
	else -&gt; 0
&#125;</code></pre>
<h3 id="类型匹配"><a class="markdownIt-Anchor" href="#类型匹配"></a> 类型匹配</h3>
<pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin">fun funName(num : Number) &#x3D; when(num)&#123;
	is Int -&gt; println(&quot;num is Int&quot;)
	is Double -&gt; println(&quot;num is Double&quot;)
	else -&gt; prinln(&quot;num not support&quot;)
&#125;</code></pre>
<p><code>is</code> 是 kotlin 的关键字，作用就像 java 中的<code>instanceof</code>一样。</p>
<h3 id="无参写法"><a class="markdownIt-Anchor" href="#无参写法"></a> 无参写法</h3>
<pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin">fun funName(name : String) &#x3D; when&#123;
	name &#x3D;&#x3D; &quot;Tom&quot; -&gt; 86
	name &#x3D;&#x3D; &quot;Jim&quot; -&gt; 77
	name.startsWith(&quot;Mike&quot;) -&gt; 100
	else -&gt; 0
&#125;</code></pre>
<p>可用于模糊匹配。</p>
<p>kotlin 中比较两个对象是否相同可以用 <code>==</code>， java 中需要用<code>equals</code>函数。</p>
<h1 id="循环控制"><a class="markdownIt-Anchor" href="#循环控制"></a> 循环控制</h1>
<h2 id="for-in"><a class="markdownIt-Anchor" href="#for-in"></a> for-in</h2>
<h3 id="区间定义"><a class="markdownIt-Anchor" href="#区间定义"></a> 区间定义</h3>
<p>定义一个闭区间：</p>
<pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin">val range &#x3D; 0..10 &#x2F;&#x2F; 即[0,10]</code></pre>
<p>其中<code>..</code>是关键字。</p>
<p>左闭右开区间：</p>
<pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin">range &#x3D; 0 until 10 &#x2F;&#x2F; [0,10)</code></pre>
<p>降序区间：</p>
<pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin">range &#x3D; 10 downTo 0 &#x2F;&#x2F; [10,0]</code></pre>
<h3 id="例子"><a class="markdownIt-Anchor" href="#例子"></a> 例子</h3>
<pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin">fun funName()&#123;
	for(i in 0..10)&#123;
		&#x2F;&#x2F; code
	&#125;
&#125;</code></pre>
<pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin">fun funName()&#123;
	for(i in range)&#123;
		&#x2F;&#x2F; code
	&#125;
&#125;</code></pre>
<h3 id="变量自增"><a class="markdownIt-Anchor" href="#变量自增"></a> 变量自增</h3>
<p>使用<code>step</code>关键字。</p>
<pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin">fun funName()&#123;
	for(i in 0..10 step 2)&#123;
		&#x2F;&#x2F; code
	&#125;
&#125;</code></pre>
<p>每次循环之间 i 自增2。如果不写则默认自增1。</p>
<h1 id="面向对象"><a class="markdownIt-Anchor" href="#面向对象"></a> 面向对象</h1>
<p>Person 类：</p>
<pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin">class Person &#123;
	var name &#x3D; &quot;&quot;
	var age &#x3D; 0
	fun eat() &#123;
		println(name + &quot; is eating. He is &quot; + age + &quot; years old.&quot;)
	&#125;
&#125;</code></pre>
<p>实例化：</p>
<pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin">val p &#x3D; Person()</code></pre>
<p>没有像 java 中的<code>new</code>关键字。</p>
<h1 id="继承与接口"><a class="markdownIt-Anchor" href="#继承与接口"></a> 继承与接口</h1>
<p>kotlin 中默认每一个非抽象类都是无法继承的。使用<code>open</code>关键字让类变为可继承。</p>
<p>抽象类无法创建实例，必须被继承后才能实例化。所以抽象类必须是可继承的。</p>
<pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin">open class Person &#123;
	&#x2F;&#x2F; code
&#125;

class Student : Person() &#123;
	var sno &#x3D; &quot;&quot;
	var grade &#x3D; 0
&#125;</code></pre>
<p>子类使用<code>:</code>来继承父类。同时实现接口也是这个关键字。</p>
<pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin">class Student : Person(), Study &#123;
	var sno &#x3D; &quot;&quot;
	var grade &#x3D; 0
&#125;</code></pre>
<h2 id="单例类"><a class="markdownIt-Anchor" href="#单例类"></a> 单例类</h2>
<p>在内存中只有一个实例的类。</p>
<p>使用<code>object</code>关键字。</p>
<pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin">object Singleton &#123;
	fun singletonFun() &#123;
		println(&quot;singletonFun&quot;)
	&#125;
&#125;</code></pre>
<h2 id="数据类"><a class="markdownIt-Anchor" href="#数据类"></a> 数据类</h2>
<p>数据类是一种只保存数据的类。</p>
<p>使用<code>data</code>关键字。</p>
<pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin">data class Person(val name: String, val age: Int)</code></pre>
<h1 id="空指针检查"><a class="markdownIt-Anchor" href="#空指针检查"></a> 空指针检查</h1>
<p>kotlin 在编译时进行空指针检查，而非运行时。</p>
<p>kotlin 默认所有参数都是非空的，如果想声明一个可为空的变量，需要在变量类型后加<code>?</code>。</p>
<pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin">var name : String? &#x3D; null</code></pre>
<p><code>?</code>表示这个变量可以为空。</p>
<h2 id="判空辅助操作符"><a class="markdownIt-Anchor" href="#判空辅助操作符"></a> 判空辅助操作符</h2>
<p><code>?.</code>：如果对象为空则返回 null，否则执行后面的操作。</p>
<pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin">if(a !&#x3D; null)&#123;
	a.method()
&#125;else&#123;
	null
&#125;</code></pre>
<p>等价于：</p>
<pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin">a?.method()</code></pre>
<hr />
<p><code>?:</code>：如果对象为空则返回后面的值。</p>
<pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin">val c &#x3D; if(a !&#x3D; null)&#123;
	a
&#125;else&#123;
	0
&#125;</code></pre>
<p>等价于：</p>
<pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin">val c &#x3D; a ?: 0</code></pre>
<h2 id="非空断言"><a class="markdownIt-Anchor" href="#非空断言"></a> 非空断言</h2>
<p><code>!!</code>：强制忽略空指针异常检查。</p>
<p>如：</p>
<pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin">val a!!.method()</code></pre>
<p>无论 a 是否为 null ，都会执行<code>method()</code>。</p>
<h2 id="let-函数实现一次判断"><a class="markdownIt-Anchor" href="#let-函数实现一次判断"></a> let 函数实现一次判断</h2>
<pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin">if(a &#x3D;&#x3D; null)&#123;
	return
&#125;
a.method()
a.method2()</code></pre>
<p>等价于：</p>
<pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin">a?.let&#123;
	it.method()
	it.method2()
&#125; &#x2F;&#x2F; lambda 表达式</code></pre>
<h1 id="标准函数"><a class="markdownIt-Anchor" href="#标准函数"></a> 标准函数</h1>
<p>指的是 Standard.kt 文件中定义的函数。前面的 <code>let</code> 也是标准函数。</p>
<h2 id="with"><a class="markdownIt-Anchor" href="#with"></a> with</h2>
<p>接收一个对象和一个 lambda 表达式，返回 lambda 表达式的执行结果。</p>
<pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin">val result &#x3D; with(obj) &#123;
	&#x2F;&#x2F; obj的上下文
	&quot;value&quot; &#x2F;&#x2F; with函数的返回值
&#125;</code></pre>
<h3 id="with-函数应用举例"><a class="markdownIt-Anchor" href="#with-函数应用举例"></a> with 函数应用举例</h3>
<pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin">val list &#x3D; listOf(&quot;Apple&quot;, &quot;Banana&quot;, &quot;Orange&quot;, &quot;Pear&quot;, &quot;Grape&quot;)
val builder &#x3D; StringBuilder()
builder.append(&quot;Start eating fruits.\n&quot;)
for (fruit in list) &#123;
	builder.append(fruit).append(&quot;\n&quot;)
&#125;
builder.append(&quot;Ate all fruits.&quot;)
val result &#x3D; builder.toString()
println(result)</code></pre>
<p>输出：</p>
<pre class="line-numbers language-none"><code class="language-none">Start eating fruits.
Apple
Banana
Orange
Pear
Grape
Ate all fruits.</code></pre>
<p>使用<code>with</code>函数：</p>
<pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin">val list &#x3D; listOf(&quot;Apple&quot;, &quot;Banana&quot;, &quot;Orange&quot;, &quot;Pear&quot;, &quot;Grape&quot;)
val result &#x3D; with(StringBuilder()) &#123;
	append(&quot;Start eating fruits.\n&quot;)
	for (fruit in list) &#123;
		append(fruit).append(&quot;\n&quot;)
	&#125;
	append(&quot;Ate all fruits.&quot;)
	toString()
&#125;
println(result)</code></pre>
<p>with 中传入了 StringBuilder 实例，这样上下文就是 StringBuilder 实例，可以直接调用 append 方法。with 函数的返回值是最后一行代码的返回值，即 toString() 方法的返回值。</p>
<h2 id="run"><a class="markdownIt-Anchor" href="#run"></a> run</h2>
<p>run 函数在对象的基础上调用，接受一个 lambda 表达式作为参数，返回值是 lambda 表达式的执行结果。</p>
<pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin">val result &#x3D; obj.run &#123;
	&#x2F;&#x2F; obj的上下文
	&quot;value&quot; &#x2F;&#x2F; run函数的返回值
&#125;</code></pre>
<p>那么<a href="#with-%E5%87%BD%E6%95%B0%E5%BA%94%E7%94%A8%E4%B8%BE%E4%BE%8B">with函数的例子</a>可以改写为：</p>
<pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin">val list &#x3D; listOf(&quot;Apple&quot;, &quot;Banana&quot;, &quot;Orange&quot;, &quot;Pear&quot;, &quot;Grape&quot;)
val result &#x3D; StringBuilder().run &#123;
	append(&quot;Start eating fruits.\n&quot;)
	for (fruit in list) &#123;
		append(fruit).append(&quot;\n&quot;)
	&#125;
	append(&quot;Ate all fruits.&quot;)
	toString()
&#125;
println(result)</code></pre>
<h2 id="apply"><a class="markdownIt-Anchor" href="#apply"></a> apply</h2>
<p>apply 函数和 run 函数很相似，也是在对象的基础上调用 lambda 表达式，但 apply 函数返回的是对象本身。</p>
<pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin">val result &#x3D; obj.apply &#123;
	&#x2F;&#x2F; obj的上下文
	&quot;value&quot; &#x2F;&#x2F; apply函数的返回值
&#125;</code></pre>
<p>改写<a href="#with-%E5%87%BD%E6%95%B0%E5%BA%94%E7%94%A8%E4%B8%BE%E4%BE%8B">with函数的例子</a>：</p>
<pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin">val list &#x3D; listOf(&quot;Apple&quot;, &quot;Banana&quot;, &quot;Orange&quot;, &quot;Pear&quot;, &quot;Grape&quot;)
val result &#x3D; StringBuilder().apply &#123;
	append(&quot;Start eating fruits.\n&quot;)
	for (fruit in list) &#123;
		append(fruit).append(&quot;\n&quot;)
	&#125;
	append(&quot;Ate all fruits.&quot;)
&#125;.toString() &#x2F;&#x2F; 注意这里的 toString() 方法，是 StringBuilder.toString()
println(result)</code></pre>
<h1 id="静态方法"><a class="markdownIt-Anchor" href="#静态方法"></a> 静态方法</h1>
<p>kotlin 中没有静态方法的概念，但可以通过单例类或是伴生对象来实现。</p>
<h2 id="单例类-2"><a class="markdownIt-Anchor" href="#单例类-2"></a> 单例类</h2>
<pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin">object Utils &#123;
	fun doAction() &#123;
		println(&quot;do action&quot;)
	&#125;
&#125;</code></pre>
<p>调用：<code>Utils.doAction()</code></p>
<p>使用单例类会使得类内所有方法都是静态方法。</p>
<h2 id="伴生对象"><a class="markdownIt-Anchor" href="#伴生对象"></a> 伴生对象</h2>
<pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin">class Utils &#123;
	fun doAction1() &#123;
		println(&quot;do action1&quot;)
	&#125;
	companion object &#123;
		fun doAction2() &#123;
			println(&quot;do action2&quot;)
		&#125;
	&#125;
&#125;</code></pre>
<p>调用：<code>Utils.doAction2()</code></p>
<p>对于一个普通类，伴生对象中的方法是静态方法，而类中的方法是实例方法。并且 kotlin 保证伴生对象的唯一性。</p>
<h2 id="真正的静态方法"><a class="markdownIt-Anchor" href="#真正的静态方法"></a> 真正的静态方法</h2>
<h3 id="jvmstatic-注解"><a class="markdownIt-Anchor" href="#jvmstatic-注解"></a> @JvmStatic 注解</h3>
<p>kotlin 中的真正的静态方法是使用<code>@JvmStatic</code>注解。</p>
<pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin">class Utils &#123;
	companion object &#123;
		@JvmStatic
		fun doAction() &#123;
			println(&quot;do action&quot;)
		&#125;
	&#125;
&#125;</code></pre>
<p>注意， @JvmStatic 注解只能用在伴生对象中或者单例类中的方法上。</p>
<h3 id="顶层方法"><a class="markdownIt-Anchor" href="#顶层方法"></a> 顶层方法</h3>
<p>顶层方法指的是那些没有定义在任何类中的方法。</p>
<p>想要定义顶层方法，需要在 <strong>kotlin 文件</strong>中直接定义函数，而不是定义在类中。（参考<a href="#hello-kotlin">hello kotlin</a>）</p>
<pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin">&#x2F;&#x2F; Utils.kt
fun doAction() &#123;
	println(&quot;do action&quot;)
&#125;</code></pre>
<p>如果是在 java 中调用这个方法，需要使用类名调用。</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F; Java
UtilsKt.doAction();
&#x2F;&#x2F; 编译器自动生成一个 UtilsKt 类，其中包含了 doAction 方法</code></pre>
<p>如果是在 kotlin 中调用，直接调用即可。</p>
<pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin">&#x2F;&#x2F; Kotlin
doAction()</code></pre>
]]></content>
      <categories>
        <category>第一个安卓 app</category>
      </categories>
      <tags>
        <tag>kotlin</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo+next 使用备忘</title>
    <url>/1060342639.html</url>
    <content><![CDATA[<h1 id="标签插件实现的高级块"><a class="markdownIt-Anchor" href="#标签插件实现的高级块"></a> 标签插件实现的高级块</h1>
<h2 id="引用链接"><a class="markdownIt-Anchor" href="#引用链接"></a> 引用链接</h2>
<pre class="line-numbers language-none"><code class="language-none">&#123;% lg %&#125;
链接名 | 链接 | 说明 | 链接头图URL
% ...
&#123;% endlg %&#125;</code></pre>
<p>一个块里可以有多个链接。可以用 <code>%</code> 注释一条链接。</p>
<h3 id="例子"><a class="markdownIt-Anchor" href="#例子"></a> 例子</h3>
<pre class="line-numbers language-none"><code class="language-none">&#123;% lg %&#125;
EasyExcel 官方文档 | https:&#x2F;&#x2F;easyexcel.opensource.alibaba.com&#x2F;docs&#x2F;current&#x2F; | 关于Easyexcel | https:&#x2F;&#x2F;easyexcel.opensource.alibaba.com&#x2F;img&#x2F;favicon.ico
Element UI 官方文档 | https:&#x2F;&#x2F;element.eleme.cn&#x2F;#&#x2F;zh-CN | Element UI | https:&#x2F;&#x2F;element.eleme.cn&#x2F;favicon.ico
% Element UI 官方文档 | https:&#x2F;&#x2F;element.eleme.cn&#x2F;#&#x2F;zh-CN | Element UI | https:&#x2F;&#x2F;element.eleme.cn&#x2F;favicon.ico
&#123;% endlg %&#125;</code></pre>
<div class="link-grid"><div class="link-grid-container">
<object class="link-grid-image" data="https://easyexcel.opensource.alibaba.com/img/favicon.ico"></object>
<p>EasyExcel 官方文档</p><p>关于Easyexcel</p>
<a href="https://easyexcel.opensource.alibaba.com/docs/current/"></a>
</div><div class="link-grid-container">
<object class="link-grid-image" data="https://element.eleme.cn/favicon.ico"></object>
<p>Element UI 官方文档</p><p>Element UI</p>
<a href="https://element.eleme.cn/#/zh-CN"></a>
</div></div>
<hr />
<h2 id="note-块"><a class="markdownIt-Anchor" href="#note-块"></a> note 块</h2>
<pre class="line-numbers language-none"><code class="language-none">&#123;% note [class] [no-icon] [summary] %&#125;
Any content (support inline tags too).
&#123;% endnote %&#125;</code></pre>
<p><code>[class]</code> ：可选参数，支持的值： default | primary | success | info | warning | danger。<br />
<code>[no-icon]</code> ：可选参数。禁用注释中的图标。<br />
<code>[summary]</code> ：可选参数。可选的注释摘要。</p>
<h3 id="例子-2"><a class="markdownIt-Anchor" href="#例子-2"></a> 例子</h3>
<pre class="line-numbers language-none"><code class="language-none">&#123;% note %&#125;
无样式 note 块
&#123;% endnote %&#125;</code></pre>
<div class="note "><p>无样式 note 块</p>
</div>
<pre class="line-numbers language-none"><code class="language-none">&#123;% note default %&#125;
default 块
&#123;% endnote %&#125;</code></pre>
<div class="note default"><p>default 块</p>
</div>
<div class="note info"><p>info 块</p>
</div>
<div class="note danger"><p>danger 块</p>
</div>
<div class="note success"><p>success 块</p>
</div>
<pre class="line-numbers language-none"><code class="language-none">&#123;% note primary 摘要 %&#125;
这是一个具有摘要的 primary 样式的 note 块
&#123;% endnote %&#125;</code></pre>
<details class="note primary"><summary><p>摘要</p>
</summary>
<p>这是一个具有摘要的 primary 样式的 note 块</p>

</details>
<p>在 note 块中的 markdown 语法和在块外面是一样的。</p>
<div class="link-grid"><div class="link-grid-container">
<object class="link-grid-image" data="https://theme-next.js.org/images/next.png"></object>
<p>Next 主题标签插件</p><p>note</p>
<a href="https://theme-next.js.org/docs/tag-plugins/note"></a>
</div></div>
<hr />
<h1 id="mermaid-渲染"><a class="markdownIt-Anchor" href="#mermaid-渲染"></a> mermaid 渲染</h1>
<p>如果使用 markdown 语法绘制mermaid，需要引入 js 。在 <code>themes\next\layout\_partials\footer.njk</code> 中添加以下内容：</p>
<pre class="line-numbers language-njk" data-language="njk"><code class="language-njk">&#123;%- if theme.mermaid.enable  %&#125;
  &lt;script src&#x3D;&#39;https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;npm&#x2F;mermaid@11.5.0&#x2F;dist&#x2F;mermaid.min.js&#39;&gt;&lt;&#x2F;script&gt;
  &lt;script&gt;
    if (window.mermaid) &#123;
      mermaid.initialize(&#123;theme: &#39;default&#39;&#125;);
    &#125;
  &lt;&#x2F;script&gt;
&#123;% endif %&#125;</code></pre>
<p>如果使用 next 主题提供的 mermaid 渲染，在主题配置中打开即可：</p>
<pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"># Mermaid tag
mermaid:
  enable: true
  # Available themes: default | dark | forest | neutral
  theme:
    light: forest
    dark: dark</code></pre>
<div class="note info"><p>以上只是本人的猜测，未经测试。</p>
</div>
<h2 id="例子-3"><a class="markdownIt-Anchor" href="#例子-3"></a> 例子</h2>
<pre class="line-numbers language-none"><code class="language-none">&#123;% mermaid graph LR %&#125;
A[Hard] --&gt;|Text| B(Round)
B --&gt; C&#123;Decision&#125;
C --&gt;|One| D[Result 1]
C --&gt;|Two| E[Result 2]
&#123;% endmermaid %&#125;

&#96; &#96; &#96;mermaid
graph LR
A[Hard] --&gt;|Text| B(Round)
B --&gt; C&#123;Decision&#125;
C --&gt;|One| D[Result 1]
C --&gt;|Two| E[Result 2]
&#96; &#96; &#96;</code></pre>
<p>next 的 mermaid 块：</p>
<pre>
<code class="mermaid">
graph LR
A[Hard] --&gt;|Text| B(Round)
B --&gt; C{Decision}
C --&gt;|One| D[Result 1]
C --&gt;|Two| E[Result 2]
</code>
</pre>
<p>markdown 的 mermaid 块：</p>
<pre class="mermaid">graph LR
A[Hard] -->|Text| B(Round)
B --> C{Decision}
C -->|One| D[Result 1]
C -->|Two| E[Result 2]</pre>
<p>为啥 markdown 绘制的图有背景？</p>
<div class="link-grid"><div class="link-grid-container">
<object class="link-grid-image" data="\images\apple-touch-icon-next.png"></object>
<p>Next主题</p><p>mermaid 标签</p>
<a href="https://theme-next.js.org/docs/tag-plugins/mermaid"></a>
</div></div>
<h1 id="为博客增加版权声明"><a class="markdownIt-Anchor" href="#为博客增加版权声明"></a> 为博客增加版权声明</h1>
<p>next 主题自带此功能，只需要在 <code>_config.next.yaml</code> 中打开即可：</p>
<pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml">creative_commons:
  # Available values: by | by-nc | by-nc-nd | by-nc-sa | by-nd | by-sa | cc-zero
  license: by-nc-sa
  # Available values: big | small
  size: small
  sidebar: true # 在侧边栏显示
  post: true # 为每篇博客显示</code></pre>
<p>可以自定义样式，具体参考：</p>
<div class="link-grid"><div class="link-grid-container">
<object class="link-grid-image" data="https://i.imgur.com/kWTWXvI.jpg"></object>
<p>Gui Blog</p><p>网站的工具人</p>
<a href="https://guiblogs.com/hexo30-21/"></a>
</div></div>
]]></content>
      <categories>
        <category>软件工具</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>next</tag>
      </tags>
  </entry>
  <entry>
    <title>windows 本地部署 photoPrism</title>
    <url>/2888069175.html</url>
    <content><![CDATA[<h1 id="起因"><a class="markdownIt-Anchor" href="#起因"></a> 起因</h1>
<p>把带地理位置信息的照片上传到 google 相册后，可以在地图中查看每张照片在地图上的标点。但是 google 相册云空间有限；使用 mod 的话总感觉有风险；并且上传照片到云上也怕隐私泄露（ google 之前拿用户照片来训练 ai ）。</p>
<p>安卓端开源的 <a href="https://github.com/deckerst/aves">Aves 相册</a>也有这个功能，但是照片必须在本地。然而我不会把大量照片放在一部手机上，更偏向于放在桌面端设备。</p>
<p>在网上搜索开源照片管理工具，找到了这篇<a href="https://www.cnblogs.com/ryanyangcs/p/18322866">云部署教程</a>推荐。</p>
<h1 id="photoprism-介绍"><a class="markdownIt-Anchor" href="#photoprism-介绍"></a> photoPrism 介绍</h1>
<ul>
<li>开源</li>
<li>google 相册平替</li>
<li>具有基本的 AI 分类功能</li>
</ul>
<h1 id="部署-photoprism"><a class="markdownIt-Anchor" href="#部署-photoprism"></a> 部署 photoPrism</h1>
<p>先决条件： 安装 Docker Desktop ，这里不赘述。</p>
<h2 id="下载配置文件"><a class="markdownIt-Anchor" href="#下载配置文件"></a> 下载配置文件</h2>
<p>打开<a href="https://www.photoprism.app/plus/kb/quickstart">官方文档</a>，找到<a href="https://www.photoprism.app/plus/kb/quickstart#:~:text=Step%201%3A%20Customize%20Configuration">Step 1: Customize Configuration 部分</a>，点击 windows 右边的下载链接，下载配置文件 <code>compose.yaml</code> 。</p>
<h2 id="初始化和启动"><a class="markdownIt-Anchor" href="#初始化和启动"></a> 初始化和启动</h2>
<p>在配置文件的路径下打开 cmd 。注意，接下来的命令会在配置文件的路径下创建 photoPrism 实例（刚开始没注意，放在桌面启动， C 盘差点炸了）。</p>
<p>依次输入官方提供的两条命令：</p>
<pre class="line-numbers language-cmd" data-language="cmd"><code class="language-cmd">docker compose pull
docker compose up -d</code></pre>
<p>第一条命令会下载所需的 image 以及数据库；第二条命令则是以当前配置启动 photoprism 。</p>
<p>photoPrism 默认运行在<a href="localhost:2342">本地 2342 端口</a>。启动后打开浏览器， 等待界面加载完毕。登录的账号密码为:</p>
<pre class="line-numbers language-none"><code class="language-none">账号：admin
密码：insecure</code></pre>
<p>后续可以在配置文件中修改：</p>
<pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml">environment:
    PHOTOPRISM_ADMIN_USER: &quot;admin&quot;
    PHOTOPRISM_ADMIN_PASSWORD: &quot;insecure&quot;</code></pre>
<p>登陆后，点击左边侧边栏中的 Settings ，之后在右上角找到 language ，可以将界面改为中文。</p>
<h1 id="如何加载已有图片"><a class="markdownIt-Anchor" href="#如何加载已有图片"></a> 如何加载已有图片</h1>
<p>打开配置文件，转到95行，可以看到 photoprism 的文件挂载路径。将 <code>~/Photos:/photoprism/originals</code> 其中的 <code>~/Photos</code> 修改为你的照片文件的路径。</p>
<pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml">volumes:
    # &quot;C:&#x2F;user&#x2F;username&#x2F;folder:&#x2F;photoprism&#x2F;folder&quot;       # example
    - &quot;~&#x2F;Pictures:&#x2F;photoprism&#x2F;originals&quot;                 # original media files (photos and videos)
    # - &quot;D:&#x2F;example&#x2F;family:&#x2F;photoprism&#x2F;originals&#x2F;family&quot; # *additional* media folders can be mounted like this
    # - &quot;E:&#x2F;:&#x2F;photoprism&#x2F;import&quot;                         # *optional* base folder from which files can be imported to originals
    - &quot;.&#x2F;storage:&#x2F;photoprism&#x2F;storage&quot;                    # *writable* storage folder for cache, database, and sidecar files (never remove)</code></pre>
<p>重新启动 photoPrism （可以在 Docker Desktop 中手动重启）。</p>
<p>点击侧边栏的资料库，确认顶部 tab 栏的选项卡为索引，点击开始，等待加载完毕即可。加载时间取决于电脑性能以及照片数量。</p>
<hr />
<p>参考文档</p>
<p><a href="https://www.cnblogs.com/ryanyangcs/p/18322866">米开朗基杨的博客</a></p>
<p><a href="https://www.photoprism.app/plus/kb/quickstart">photoPrism 官方文档</a></p>
]]></content>
      <categories>
        <category>软件工具</category>
      </categories>
      <tags>
        <tag>windows</tag>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>开发日记</title>
    <url>/786968787.html</url>
    <content><![CDATA[<h1 id="后端生成并返回-excel-表格前端下载"><a class="markdownIt-Anchor" href="#后端生成并返回-excel-表格前端下载"></a> 后端生成并返回 excel 表格，前端下载</h1>
<p>后端 Controller ：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">@GetMapping(&quot;&#x2F;excel&#x2F;&#123;id&#125;&quot;)
public ResponseEntity&lt;byte[]&gt; exportExcel(@PathVariable(&quot;id&quot;) Long id) throws IOException &#123;
    try &#123;
        &#x2F;&#x2F; 1. 读取 Excel 模板
        ClassPathResource resource &#x3D; new ClassPathResource(&quot;template&#x2F;bridge&#x2F;bridgeSJ29.xlsx&quot;);
        InputStream templateInputStream &#x3D; resource.getInputStream();

        &#x2F;&#x2F; 2. 获取数据
        BridgeSJ29 excelData &#x3D; bridgeSJ29Service.selectBridgeSJ29ById(id);
        if (excelData &#x3D;&#x3D; null) &#123;
            return ResponseEntity.notFound().build();
        &#125;

        &#x2F;&#x2F; 处理时间格式
        &#x2F;&#x2F; code...

        &#x2F;&#x2F; 3. 使用 ByteArrayOutputStream 代替本地文件
        ByteArrayOutputStream outputStream &#x3D; new ByteArrayOutputStream();

        &#x2F;&#x2F; 4. 使用 EasyExcel 进行填充
        EasyExcel.write(outputStream)
                .withTemplate(templateInputStream) &#x2F;&#x2F; 绑定模板
                .sheet()  &#x2F;&#x2F; 选择第一个 Sheet
                .doFill(excelData); &#x2F;&#x2F; 填充数据

        &#x2F;&#x2F; 5. 关闭流
        templateInputStream.close();
        outputStream.close();

        &#x2F;&#x2F; 6. 获取字节数组
        byte[] excelBytes &#x3D; outputStream.toByteArray();

        &#x2F;&#x2F; 7. 设置 HTTP 头
        HttpHeaders headers &#x3D; new HttpHeaders();
        headers.add(HttpHeaders.CONTENT_DISPOSITION, &quot;attachment; filename&#x3D;bridgeSJ29_&quot; + id + &quot;.xlsx&quot;);
        headers.setContentType(MediaType.APPLICATION_OCTET_STREAM);
        headers.setContentLength(excelBytes.length);

        &#x2F;&#x2F; 8. 返回字节数组，而不是 ByteArrayResource
        return ResponseEntity.ok()
                .headers(headers)
                .body(excelBytes);
    &#125; catch (Exception e) &#123;
        e.printStackTrace();
        return ResponseEntity.status(500).build();
    &#125;
&#125;</code></pre>
<p>这样写返回的就是 excel 文件的 blob 数据，前端直接触发下载即可：</p>
<pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&#x2F;**导出Excel *&#x2F;
async handleExportExcel() &#123;
    try &#123;
    const response &#x3D; await exportExcel(this.rowid);&#x2F;&#x2F; 后端返回的response就是一个blob对象，直接下载即可

    &#x2F;&#x2F; 创建 Blob 并触发下载
    const blob &#x3D; new Blob([response], &#123; type: &#39;application&#x2F;octet-stream&#39; &#125;);
    const link &#x3D; document.createElement(&#39;a&#39;);
    link.href &#x3D; URL.createObjectURL(blob);
    link.download &#x3D; &#39;混凝土施工记录表SJ29_&#39; + new Date().getTime() + &#39;_.xlsx&#39;;  &#x2F;&#x2F; 使用固定的文件名
    document.body.appendChild(link);
    link.click();

    &#x2F;&#x2F; 清理Url对象
    URL.revokeObjectURL(link.href);
    document.body.removeChild(link);

    this.$message.success(&#39;Excel 下载成功！&#39;);
    &#125; catch (error) &#123;
    console.error(&#39;Excel 下载失败:&#39;, error);
    this.$message.error(&#39;下载失败，请重试！&#39;);
    &#125; finally &#123;
    this.loading &#x3D; false;
    &#125;
&#125;,</code></pre>
<p>之前写的时候 ai 一直说需要从 response 中读取头部来获取文件名，但是实际上返回的 response 没有头部。直接就是 blob 数据，连data部分都没有。所以直接下载即可。</p>
<pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&#x2F;&#x2F; 创建 Blob 并触发下载
const blob &#x3D; new Blob([response], &#123; type: &#39;application&#x2F;octet-stream&#39; &#125;);
&#x2F;&#x2F; 之前一直写的是 response.data ，一直是 undefined</code></pre>
<div class="link-grid"><div class="link-grid-container">
<object class="link-grid-image" data="https://easyexcel.opensource.alibaba.com/img/favicon.ico"></object>
<p>EasyExcel 官方文档</p><p>最简单的填充</p>
<a href="https://easyexcel.opensource.alibaba.com/docs/current/quickstart/fill#%E6%9C%80%E7%AE%80%E5%8D%95%E7%9A%84%E5%A1%AB%E5%85%85"></a>
</div></div>
<h1 id="后端返回的实体类字段名与定义的字段名不一致"><a class="markdownIt-Anchor" href="#后端返回的实体类字段名与定义的字段名不一致"></a> 后端返回的实体类字段名与定义的字段名不一致</h1>
<h2 id="问题"><a class="markdownIt-Anchor" href="#问题"></a> 问题</h2>
<p>数据库中有数据，后端能接收到数据，但是前端web页面的表格中没有显示数据。</p>
<h2 id="排查"><a class="markdownIt-Anchor" href="#排查"></a> 排查</h2>
<ul>
<li>前端表格中对应的字段名均正确；</li>
<li>后端实体类中对应的属性名均正确；</li>
<li>数据库中对应的字段名均正确；</li>
</ul>
<h2 id="解决"><a class="markdownIt-Anchor" href="#解决"></a> 解决</h2>
<ol>
<li>在前端中<strong>打印后端发送来的数据，发现与期望字段名不一致</strong>。比如期望<code>sgphb_wjj</code>，收到的却是<code>ssgxb_wjj</code>。</li>
<li>在<strong>后端中查找相应字符串</strong>，发现实体类中的<code>getter</code>和<code>setter</code>方法的<strong>方法名与错误的字段名对应</strong>，方法体中的<strong>属性名与正确的字段名对应</strong>。猜测是<strong>方法名错误导致返回前端的字段名错误</strong>。</li>
<li>修正方法名后，问题解决。</li>
</ol>
<p><img data-src="https://i.meee.com.tw/k8U1gfs.png" alt="方法名对比" /></p>
<h2 id="原理"><a class="markdownIt-Anchor" href="#原理"></a> 原理</h2>
<p>截取部分AI解释如下。</p>
<p><img data-src="https://i.meee.com.tw/qxPjA23.png" alt="AI 解释" /></p>
<p><img data-src="https://i.meee.com.tw/HuY5bjm.png" alt="AI 解释反射机制" /></p>
<p>在这个过程中，当首字母之后连续的字母都是大写时，通常会将整个大写部分都视为一个整体，然后统一将首字母小写：</p>
<p><code>SJ28Item1List -&gt; sj28Item1List</code></p>
<h2 id="jsonproperty-注解"><a class="markdownIt-Anchor" href="#jsonproperty-注解"></a> <code>@JsonProperty</code> 注解</h2>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">import com.fasterxml.jackson.annotation.JsonProperty;

public class Example &#123;
    @JsonProperty(&quot;customName&quot;)
    private String name;

    public String getName() &#123;
        return name;
    &#125;

    public void setName(String name) &#123;
        this.name &#x3D; name;
    &#125;
&#125;</code></pre>
<p>在上述代码中，尽管 <code>getter</code> 和 <code>setter</code> 方法遵循 Java Bean 规范，但是由于使用了 <code>@JsonProperty(&quot;customName&quot;)</code> 注解，该属性在序列化后会被命名为 <code>customName</code> 而不是 <code>name</code>。</p>
<p>总之，一般情况下是根据 Java Bean 规范，由 <code>getter</code> 和 <code>setter</code> 方法名来决定最终返回给前端的字段名，但可以通过注解等方式来进行自定义修改，避免受到方法名的限制。</p>
<h1 id="easyexcel-实现列表填充"><a class="markdownIt-Anchor" href="#easyexcel-实现列表填充"></a> EasyExcel 实现列表填充</h1>
<p>这里填充的是图片。模板内的占位符为 <code>&#123;.imageCell&#125;</code> 。</p>
<p>实体类内的静态类：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">@Getter
@Setter
public static class Image &#123;
    private WriteCellData&lt;Void&gt; imageCell;

    &#x2F;*
    * 为了实现单张图片的格式化（例如占多个单元格等），使用 ImageData 。
    * EasyExcel 根据一个 WriteCellData 对象来对一个单元格进行操作。
    * *&#x2F;

    public Image(URL imageURL) throws IOException &#123;
        this.imageCell &#x3D; createWriteCellData(imageURL);
    &#125;

    private WriteCellData&lt;Void&gt; createWriteCellData(URL url) throws IOException &#123;
        WriteCellData&lt;Void&gt; cellData &#x3D; new WriteCellData&lt;&gt;(); &#x2F;&#x2F; 单元格操作对象
        ImageData imageData &#x3D; new ImageData(); &#x2F;&#x2F; 图片数据对象

        imageData.setImage(downloadImage(url));
        imageData.setImageType(ImageData.ImageType.PICTURE_TYPE_PNG);

        imageData.setRelativeFirstRowIndex(0);&#x2F;&#x2F; 距离占位符单元格 0 行
        imageData.setRelativeFirstColumnIndex(0); &#x2F;&#x2F; 距离占位符单元格 0 列
        &#x2F;&#x2F; 以上两句可以不写，毕竟本来就要填充到占位符的地方

        imageData.setRelativeLastRowIndex(0); &#x2F;&#x2F; 图片占 1 行
        imageData.setRelativeLastColumnIndex(1); &#x2F;&#x2F; 图片横向占 2 列

        cellData.setImageDataList(List.of(imageData));&#x2F;&#x2F; 将图片数据对象放入一个不可变列表中，并将这个列表返回给单元格操作对象

        return cellData;
    &#125;

    private byte[] downloadImage(URL url) throws IOException &#123;
        &#x2F;&#x2F; 下载图片保存为二进制文件
    &#125;
&#125;</code></pre>
<p>填充列表</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F; 构建 ExcelWriter 对象，并禁用自动关闭流，实现多次操作
ExcelWriter excelWriter &#x3D; EasyExcel.write(outputStream)
        .withTemplate(templateInputStream)
        .autoCloseStream(false)
        .build();

&#x2F;&#x2F; 构建默认的 WriteSheet（这里假设只有一个 sheet）
WriteSheet sheet &#x3D; EasyExcel.writerSheet().build();

&#x2F;&#x2F; 使用 List&lt;Image&gt; 让 EasyExcel 按行填充
List&lt;SJ24.Image&gt; imageList &#x3D; new ArrayList&lt;&gt;();
imageList.add(new SJ24.Image(new URL(excelData.getCrackDistributionMap15()))); &#x2F;&#x2F; 第一张图片
imageList.add(new SJ24.Image(new URL(excelData.getCrackDistributionMap25()))); &#x2F;&#x2F; 第二张图片
excelWriter.fill(imageList, sheet);

&#x2F;&#x2F; 填充文字数据
excelWriter.fill(excelData,sheet);

&#x2F;&#x2F; 结束写入，刷新数据到流中
excelWriter.finish();</code></pre>
<div class="link-grid"><div class="link-grid-container">
<object class="link-grid-image" data="https://easyexcel.opensource.alibaba.com/img/favicon.ico"></object>
<p>EasyExcel 官方文档</p><p>填充列表</p>
<a href="https://easyexcel.opensource.alibaba.com/docs/current/quickstart/fill#%E5%A1%AB%E5%85%85%E5%88%97%E8%A1%A8"></a>
</div></div>
<h1 id="element-ui-前端时间选择问题"><a class="markdownIt-Anchor" href="#element-ui-前端时间选择问题"></a> Element UI 前端时间选择问题</h1>
<pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;el-form-item label&#x3D;&quot;施工日期&quot; prop&#x3D;&quot;constructionTime&quot;&gt;
    &lt;el-date-picker clearable v-model&#x3D;&quot;form.constructionTime&quot; type&#x3D;&quot;date&quot; placeholder&#x3D;&quot;请选择施工日期&quot;
    format&#x3D;&quot;yyyy&#x2F;MM&#x2F;dd&quot; value-format&#x3D;&quot;yyyy&#x2F;MM&#x2F;dd&quot; &#x2F;&gt;
&lt;&#x2F;el-form-item&gt;

&lt;el-form-item label&#x3D;&quot;开始时间&quot; prop&#x3D;&quot;startTime&quot;&gt;
    &lt;el-time-picker clearable v-model&#x3D;&quot;form.startTime&quot; placeholder&#x3D;&quot;请选择开始时间&quot; disabled-seconds format&#x3D;&quot;H:mm&quot;
    value-format&#x3D;&quot;H:mm&quot; &#x2F;&gt;
&lt;&#x2F;el-form-item&gt;

&lt;el-form-item label&#x3D;&quot;结束时间&quot; prop&#x3D;&quot;endTime&quot;&gt;
    &lt;el-time-picker clearable v-model&#x3D;&quot;form.endTime&quot; placeholder&#x3D;&quot;请选择结束时间&quot; disabled-seconds format&#x3D;&quot;H:mm&quot;
    value-format&#x3D;&quot;H:mm&quot; &#x2F;&gt;
&lt;&#x2F;el-form-item&gt;</code></pre>
<p>以<strong>施工日期</strong>字段为例，因为设置了 <code>value-format</code> 属性，所以若<strong>数据库里</strong>的对应字段的格式与<strong>该属性规定</strong>的格式不符，前端选择时就会报错。</p>
<p>比如数据库返回的字段值是 <code>yyyy-MM-dd</code> ， <code>value-format</code> 属性设置为 <code>yyyy/MM/dd</code> ，则在操作这个组件的时候就会报错：</p>
<pre class="line-numbers language-none"><code class="language-none">TypeError: date.getFullYear is not a function ...
TypeError: date.getHours is not a function ...
...</code></pre>
<details class="note info"><summary><p>为什么是 <code>date</code> ？</p>
</summary>
<p>可能是组件无法解析绑定值的格式的时候默认解析为 <code>Date</code> 对象了吧。</p>

</details>
<p>所以选择将数据库中有关时间的字段设置为 <code>varchar</code> 类型，方便更改格式。（ <code>date</code> 类型的字段的格式只能是 <code>yyyy-MM-dd</code> ）</p>
<div class="link-grid"><div class="link-grid-container">
<object class="link-grid-image" data="https://element.eleme.cn/favicon.ico"></object>
<p>Element UI 官方文档</p><p>日期选择器</p>
<a href="https://element.eleme.cn/#/zh-CN/component/date-picker#ri-qi-ge-shi"></a>
</div></div>
<p>&lt;%- mail_to(‘Ant.567@qq.com’) %&gt;</p>
]]></content>
      <categories>
        <category>施工数据采集系统</category>
      </categories>
      <tags>
        <tag>springboot</tag>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>常用控件</title>
    <url>/3355239386.html</url>
    <content><![CDATA[<h1 id="textview"><a class="markdownIt-Anchor" href="#textview"></a> TextView</h1>
<p>用于显示文本。</p>
<pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;TextView
    android:id&#x3D;&quot;@+id&#x2F;textView&quot;
    android:layout_width&#x3D;&quot;match_parent&quot;
    android:layout_height&#x3D;&quot;wrap_content&quot;
    android:gravity&#x3D;&quot;center&quot;
    android:text&#x3D;&quot;This is TextView&quot;&#x2F;&gt;</code></pre>
<p><code>android:gravity</code> 指定文字的对齐方式。</p>
]]></content>
      <categories>
        <category>第一个安卓 app</category>
        <category>布局和控件</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title>界面布局</title>
    <url>/3340243686.html</url>
    <content><![CDATA[<h1 id="常用布局"><a class="markdownIt-Anchor" href="#常用布局"></a> 常用布局</h1>
<h2 id="linearlayout"><a class="markdownIt-Anchor" href="#linearlayout"></a> LinearLayout</h2>
<p>线性布局，元素呈线性排列，不多解释。</p>
<p><code>android:orientation</code> 属性可以指定控件的排列方式，默认为水平排列。</p>
<p>控件常用属性：</p>
<table>
<thead>
<tr>
<th style="text-align:center">属性名</th>
<th style="text-align:center">值</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">android:layout_<mark>gravity</mark></td>
<td style="text-align:center">top,bottom,left,right</td>
<td style="text-align:center">对齐方向</td>
</tr>
</tbody>
</table>
<h2 id="relativelayout"><a class="markdownIt-Anchor" href="#relativelayout"></a> RelativeLayout</h2>
<p>相对布局，元素可以相对于父容器确定位置，也可以相对于其他控件。</p>
<p>控件常用属性：</p>
<table>
<thead>
<tr>
<th style="text-align:center">属性名</th>
<th style="text-align:center">值</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">android:layout_<mark>centerInParent</mark></td>
<td style="text-align:center">boolean</td>
<td style="text-align:center">处于父容器<mark>中心</mark></td>
</tr>
<tr>
<td style="text-align:center">android:layout_<mark>alignParentTop</mark></td>
<td style="text-align:center">boolean</td>
<td style="text-align:center">与父容器<mark>顶部</mark>对齐</td>
</tr>
<tr>
<td style="text-align:center">android:layout_<mark>alignParentBottom</mark></td>
<td style="text-align:center">boolean</td>
<td style="text-align:center">与父容器<mark>底部</mark>对齐</td>
</tr>
<tr>
<td style="text-align:center">android:layout_<mark>alignParentLeft</mark></td>
<td style="text-align:center">boolean</td>
<td style="text-align:center">与父容器<mark>左边</mark>对齐</td>
</tr>
<tr>
<td style="text-align:center">android:layout_<mark>alignParentRight</mark></td>
<td style="text-align:center">boolean</td>
<td style="text-align:center">与父容器<mark>右边</mark>对齐</td>
</tr>
<tr>
<td style="text-align:center">android:layout_<mark>above</mark></td>
<td style="text-align:center">控件引用</td>
<td style="text-align:center">位于控件<mark>上方</mark></td>
</tr>
<tr>
<td style="text-align:center">android:layout_<mark>below</mark></td>
<td style="text-align:center">控件引用</td>
<td style="text-align:center">位于控件<mark>下方</mark></td>
</tr>
<tr>
<td style="text-align:center">android:layout_<mark>toLeftOf</mark></td>
<td style="text-align:center">控件引用</td>
<td style="text-align:center">位于控件<mark>左侧</mark></td>
</tr>
<tr>
<td style="text-align:center">android:layout_<mark>toRightOf</mark></td>
<td style="text-align:center">控件引用</td>
<td style="text-align:center">位于控件<mark>右侧</mark></td>
</tr>
<tr>
<td style="text-align:center">android:layout_<mark>alignTop</mark></td>
<td style="text-align:center">控件引用</td>
<td style="text-align:center">与控件<mark>上边缘</mark>对齐</td>
</tr>
<tr>
<td style="text-align:center">android:layout_<mark>alignBottom</mark></td>
<td style="text-align:center">控件引用</td>
<td style="text-align:center">与控件<mark>下边缘</mark>对齐</td>
</tr>
<tr>
<td style="text-align:center">android:layout_<mark>alignLeft</mark></td>
<td style="text-align:center">控件引用</td>
<td style="text-align:center">与控件<mark>左边缘</mark>对齐</td>
</tr>
<tr>
<td style="text-align:center">android:layout_<mark>alignRight</mark></td>
<td style="text-align:center">控件引用</td>
<td style="text-align:center">与控件<mark>右边缘</mark>对齐</td>
</tr>
</tbody>
</table>
<h2 id="framelayout"><a class="markdownIt-Anchor" href="#framelayout"></a> FrameLayout</h2>
<p>帧布局。不够灵活，应用较少。</p>
<h1 id="自定义控件"><a class="markdownIt-Anchor" href="#自定义控件"></a> 自定义控件</h1>
<p>安卓中的布局与控件的继承关系：</p>
<pre class="mermaid">graph TD
    View --> TextView
    View --> ImageView
    View --> ViewGroup
    TextView --> EditText
    TextView --> Button
    ViewGroup --> LinearLayout
    ViewGroup --> RelativeLayout
    ViewGroup --> Others[……]</pre>
<p>View是Android中最基本的一种UI组件，它可以在屏幕上绘制一块矩形区域，并能响应这块区域的各种事件。</p>
<p>ViewGroup是一种特殊的View，它可以包含很多子View和子ViewGroup，是一个用于放置控件和布局的容器。</p>
<h2 id="步骤"><a class="markdownIt-Anchor" href="#步骤"></a> 步骤</h2>
<p>布局与布局之间是可以相互嵌套的；控件必须依赖于布局。所以实际上就是自定义布局，其中有自定义的控件。</p>
<pre class="mermaid">graph LR
    xml文件设计布局 --> |加载| A[class文件控制逻辑]
    A --> |完整类路径| 其他布局文件中引入</pre>
<ul>
<li>编写一个 class 作为逻辑控制，并与自定义的布局绑定（在 class 文件中编写加载布局等逻辑）。</li>
</ul>
<pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin">class YourLayout(context: Context, attrs: AttributeSet) : LinearLayout(context, attrs) &#123;
    &#x2F;&#x2F; 如果自定义控件依赖于 LinearLayout 布局，那么对应的 class 也继承于 LinearLayout 类。
    init &#123;
        LayoutInflater.from(context).inflate(R.layout.title, this) &#x2F;&#x2F; 绑定自定义的布局
       &#x2F;&#x2F; code ...
    &#125;
&#125;</code></pre>
<ul>
<li>在布局中引入。需要写入完整的类路径。</li>
</ul>
<pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;com.example.YourPackage.YourLayout
... &#x2F;&gt;</code></pre>
]]></content>
      <categories>
        <category>第一个安卓 app</category>
        <category>布局和控件</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
</search>
